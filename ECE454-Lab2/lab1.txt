#############################################################################################
utorid: chengbe4
name: Benjamin Cheng
email: benjamin.cheng@mail.utoronto.ca
#############################################################################################
Q1: List the function you think might be important to optimize to in lab2's soruce code?
A1: Please write your answer here. 
Multi-line answers are fine.
Do not modify the "###" lines or the question line above your answer. 
#############################################################################################
Q2: Report the 6 measurements using the slowest method of compilation as a baseline, report the speedup for each of the five measurements. Eg., if gcov was the slowest, and -g was twice as fast as gcov, then the speedup for -g relative to gcov would be 2.0.
A2: 
-O3: 1.0
-O2: 1.2
-Os: 1.3
gcov: 2.1
gprof: 2.3
-g: 2.4
#############################################################################################
Q3: Which is the slowest and why?
A3: -O3 is the slowest because -O3 has all optimizations turned on. The compiler is
evaluating more optimization scenarios.
#############################################################################################
Q4: Which is the fastest and why?
A4: -g is the fastest. This enables gcc to output debugging information, but the time required
for this is small compared to optimizations. As well, -g is faster than gcov and gprof since
those insert instrumentation into the binary, while -g only produces debugging information such
as line numbers.
#############################################################################################
Q5: Which of gprof and gcov is faster and why?
A5: gprof is faster than gcov, since gprof works at the function level while gcov works at the
source line level. There are thus many more instrumentation calls required for gcov.
#############################################################################################
Q6: Report the six measurements using the smallest method of compilation as a baseline, report the relative size increase for each of the six measurements. Eg., if -g was the smallest, and gprof was twice the size of -g, then the relative size increase for gprof relative to -g would be 2.0
A6: -Os 1.0
-O3 1.1
-O2 1.1
-g 2.1
gprof 2.1
gcov 3.5
#############################################################################################
Q7: Which is the smallest and why?
A7: -Os is the smallest. This optimization preset is designed for minimizing binary size.
#############################################################################################
Q8: Which is the largest and why?
A8: gcov is the largest. Each source line requires an instruction to log it.
#############################################################################################
Q9: Which of gprof and gcov is smaller and why?
A9: gprof is smaller since there are many more source lines compared to functions. Thus there
is less instrumentation required for gprof.
#############################################################################################
Q10: Report the six measurements using the slowest measurement as a baseline, also report the speedup for each version.
A10: gcov 1.0
-g 1.1
gprof 1.1
-Os 3.2
-O3 3.9
-O2 4.0
#############################################################################################
Q11: Which is the slowest and why?
A11: gcov is the slowest since aside from running the program without any optimizations,
it must log each line of source code executed.
#############################################################################################
Q12: Which is the fastest and why?
A12: The optimized binaries perform much better than the debugging variants. Out of the optimized
binaries, -O2 appears to be the fastest. -Os is -O2 but with size increasing optimizations
turned off, so -O2 is faster than the former. -O3 is supposed to have more optimizations enabled
but appears to be slightly slower than -O2, which could be just due to experimental variation.
#############################################################################################
Q13: Which of grof and gcov is faster and why?
A13: gprof is faster than gcov, again due to the fact that there are many more lines of code
to be logged by gconv, than functions to be logged by gprof.
#############################################################################################
Q14: For each version, list the top 3 functions (give function name and percentage execution time)
A14: For -g:
processRotateCWReference, 50.94%
copyFrame, 42.04%
processMoveUpReference, 1.55%

For -O2:
processRotateCWReference, 54.97%
copyFrame, 37.39%
processMoveLeftReference, 1.85%

For -O3:
processRotateCCWReference, 52.86%
copyFrame, 38.18%
processRotateCWReference, 2.88%
#############################################################################################
Q15: For the "number-one" function for -O3 (the one with the greatest percentage execution time), how does its percentage execution time compare with the percentage execution time for the same function in the -g version? How is this possible? What transformation did the compiler do and to which functions?
A15: processRotateCCWReference accounts for 52.86% in -O3, but this was essentially 0% in -g.
This is pretty much the inverse of what happened to processRotateCWReference, which indicates
that processRotateCCWReference was likely inlined into processRotateCWReference. 
#############################################################################################
Q16: Count the instructions for the function "number-one" function identified in the previous question and report the counts, as well as the reduction (reported as a ratio) in number of instructions for the -O3 version (ie., if the -O3 version has half as many instructions as the -g version, the reduction is 2.0x).
A16: -O3 had 204 instructions,
-g had 40 instructions.
0.20x reduction from -g
#############################################################################################
Q17: Based only on the gcov results (ie., donâ€™t think too much about what the code says) list the functions in the order that you would focus on optimizing them for the provided lab1 inputs and why. Identify each location by its line numbers in the original source file.
A17: <your answer here>
#############################################################################################
Q18(Bonus): Name the shortest GCC compiler flag where the compiler optimization it enables requires memory alignment. How many bytes does the data needs to be aligned?
A18: The -O2 flag enables the -falign-functions, -falign-jumps, -falign-labels, and -falign-loops optimization flags. These flags align the start of functions, jumps, labels, and loops to a power-of-two boundary that is machine dependent. On Intel x86 this is 16 bytes.
